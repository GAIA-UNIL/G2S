<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>G2S a free and flexible MPS framework, including QS and NDS  </title>
	<link rel="stylesheet" href="style.css" media="screen" type="text/css">
	<link rel="stylesheet" href="print.css" media="print" type="text/css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<!-- 	<script src="./scripte.js"></script> -->
</head>
<body>
	<header>
		<div class="inner">
			<a><h1>G2S: The GeoStatistical Server</h1></a>
			<h2>A free and flexible multiple point (geo)statistics framework including state-of-the-art algorithms:<br>QuickSampling and Narrow Distribution Selection</h2>
			<a href="https://github.com/GAIA-UNIL/G2S" class="button"><small>View project on</small> GitHub</a>
		</div>
	</header>
	<div id="content-wrapper">
		<div class="inner clearfix">
			<aside id='menuSidebar' class='sideMenuBar'>
				<div>
					<aside id="menu">
						<ul class='sideMenu'>							
							<li><a href="#briefOverview">Brief overview</a></li>
							<li><a href="#multiplRealisation">Multiple realization</a></li>
							<li><a href="#segmentSimulation">How to do a simulation by segment</a></li>
						</ul>
					</aside>
				</div>
			</aside>
			<section id="main-content">

				
				<h1 id="briefOverview">Brief overview</h1>
				<p>This page provides some additional information on how to do common tasks. It also serves as personal note to myself üòÅ</p>

				<h1 id="multiplRealisation">Multiple realization</h1>
				<p>A question that is frequently asked is how to do multiple realizations. Currently there are three different ways to do it, each one of them has pros and cons.  </p>

				<h2>The lazy solution</h2>
				<p>The simplest solution is to do a for-loop over the realizations. However, in each step the algorithm needs to wait for the data to load, and this creates an overhead</p>
				<pre><code>
sims1=numpy.empty((250,250,numberOfSimulation));
for i in range(numberOfSimulation):
	sims1[:,:,i],_=g2s('-sa',computationServer,'-a','qs','-ti',ti,'-di',numpy.zeros((250,250))*numpy.nan,'-dt',numpy.ones((1,)),'-k',1.2,'-n',50,'-j',0.5,'-s',100+i);
				</code></pre>

				<h2>For-loop without overhead</h2>
				<p>By using the G2S submission queue, it's possible to remove most of the overhead. This is the most versatile solution and it is recommended over the first solution, especially in case the computations are run on another machine. <br>Furthermore, in this solution the parameters can be changed for each realization.</p>
				<pre><code>
ids=numpy.empty((numberOfSimulation,), dtype='long');
for i in range(numberOfSimulation):
	ids[i]=g2s('-sa',computationServer,'-a','qs','-ti',ti,'-di',numpy.zeros((250,250))*numpy.nan,'-dt',numpy.ones((1,)),'-k',1.2,'-n',50,'-j',0.5,'-s',100+i,'-submitOnly');

sims2=numpy.empty((250,250,numberOfSimulation));
for i in range(numberOfSimulation):
	sims2[:,:,i],_=g2s('-sa',computationServer,'-waitAndDownload',ids[i]);
				</code></pre>

				<h2>Overdimensioning of the destination image</h2>
				<p>This is the third solution to get multiple simulations at once. Although this solution looks easier, it has more limitations (e.g., being limited same size, same parameters, etc.), and therefore it is ‚ö†Ô∏è <b>not guaranteed </b> to stay functional in the future. This last solution should only be considered in case of extremely parallelized simulations (number of threads &gt;50) and/or extremely small simulations (less than 1e4 pixels per simulation)</p>
				<pre><code>
sims3,_=g2s('-sa',computationServer,'-a','qs','-ti',ti,'-di',numpy.zeros((numberOfSimulation,250,250))*numpy.nan,'-dt',numpy.ones((1,)),'-k',1.2,'-n',50,'-j',0.5);
				</code></pre>

				
				<h1 id="segmentSimulation">How to do a simulation by segment</h1>
				<p>Although QS tends to reduce issues related to non-stationarity, it won't remove them completely. Therefore in cases with high non-stationarity, the challenge is to respect each zone separately. Here we assume that we have different training images for each specific zone.</p>

				<h2>Using a secondary variable</h2>
				<p>The first solution for doing a simulation by segment is to add a secondary variable with the information of non-stationarity. In this case the setting of the algorithm has to be identical for both training images.</p>
				<pre><code>
ti1=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/bangladesh.tiff');
ti2=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/strebelle.tiff');

dt=[0];
N=300;

ti1_bis=cat(3,ti1,zeros(size(ti1)));
ti2_bis=cat(3,ti2,ones(size(ti2)));

localKernel=cat(3,kernel,padarray(15,25*[1,1]));
% localKernel=cat(3,kernel,kernel);

sim=g2s('-a','qs','-ti',ti1_bis,ti2_bis,'-di',cat(3,nan(size(tiSelection)),tiSelection),'-dt',[0,1],'-n',50,'-k',1.5,'-j',0.5,'-ki',localKernel);
imshow(medfilt2(sim(:,:,1)))
drawnow;
pause(5)

</code></pre>

<h2>Using training image indices</h2>
<p>The second solution for doing a simulation by segment is to use a training image index map. This requires that each training image represents a stationary subdomain. Also in this case the setting of the algorithm needs to be identical between training images.</p>
<pre><code>
ti1=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/bangladesh.tiff');
ti2=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/strebelle.tiff');

dt=[0];
N=300;

sim=g2s('-a','qs','-ti',ti1,ti2,'-di',nan(size(tiSelection)),'-dt',dt,'-n',50,'-k',1.5,'-j',0.5,'-ki',kernel,'-ii',tiSelection);
imshow(medfilt2(sim))
pause(5)
</code></pre>

<h2>Simulating each subdomain sequentially</h2>
<p>The last solution for doing a simulation by segment is to do simulations per subdomain. This allows for changing the settings between each subdomain. However each subdomain is simulated sequentialy and therefore can be at the origin of some artifacts, regarding the order of simulations.</p>
<pre><code>
ti1=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/bangladesh.tiff');
ti2=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/strebelle.tiff');

dt=[0];
N=300;

path=reshape(randperm(numel(tiSelection)),size(tiSelection));
p1=path;
p1(tiSelection==0)=-inf;
p2=path;
p2(tiSelection==1)=-inf;
sim=g2s('-a','qs','-ti',ti1,'-di',nan(size(tiSelection)),'-dt',dt,'-n',50,'-k',1.5,'-j',0.5,'-ki',kernel,'-sp',p1);
sim=g2s('-a','qs','-ti',ti2,'-di',sim,'-dt',dt,'-n',50,'-k',1.5,'-j',0.5,'-ki',kernel,'-sp',p2);
imshow(medfilt2(sim))
pause(5)
</code></pre>

				<!-- <h2 id='AspecRatio'>To compensate ratio aspect</h2>
				<p>Here the problem is to compensate ratio issue in case we use pixel that are not squared. Let me clarify directly this, there is no universal solution to this problem ! &#128532; Here we will review many possible approch. </p>
 -->

<!-- 				<h2 id="SuperResolution">How to setup the algorithm to do super resolution ?</h2>
				<p>Here the challenges is to increase the resolution using a HR-LR pair of training images and a low resolution image as covariable to guide the simulation</p>

<pre><code>
</code></pre>

<pre><code>
</code></pre>

<pre><code>
</code></pre>

<pre><code>
</code></pre> -->
				
				
 			</section>
			<aside id="sidebar">

				<!-- <a href="https://github.com/GAIA-UNIL/G2S/zipball/master" class="button">
					<small>Download</small>
					.zip file
				</a>
				<a href="https://github.com/GAIA-UNIL/G2S/tarball/master" class="button">
					<small>Download</small>
					.tar.gz file
				</a>



				<p class="repo-owner"><a href="https://github.com/GAIA-UNIL/G2S">G2S</a> is maintained by <a href="https://github.com/GAIA-UNIL/"> the GAIAlab from University of Lausanne</a>.</p>
 -->
			</aside>
		</div>
	</div>
	<footer>

	</footer>


</body></html>
