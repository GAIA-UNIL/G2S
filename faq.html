<!DOCTYPE html>
<html>
<head>
	<title>G2S a free and flexible MPS framework, including QS and NDS  </title>
	<link rel="stylesheet" href="./style.css" media="screen" type="text/css">
	<link rel="stylesheet" href="./print.css" media="print" type="text/css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<!-- 	<script src="./scripte.js"></script> -->
</head>
<body>
	<header>
		<div class="inner">
			<a><h1>G2S: The GeoStatistical Server</h1></a>
			<h2>A free and flexible multiple point (geo)statistics framework including state-of-the-art algorithms:<br>QuickSampling and Narrow Distribution Selection</h2>
			<a href="https://github.com/GAIA-UNIL/G2S" class="button"><small>View project on</small> GitHub</a>
		</div>
	</header>
	<div id="content-wrapper">
		<div class="inner clearfix">
<!-- 			<aside id='menuSidebar' class='sideMenuBar'>
				<div>
					<aside id="menu">
						<ul class='sideMenu'>							
							<li><a href="#briefOverview">Brief overview</a></li>
							<li><a href="#serverAutostart">Server autostart</a></li>
							<li><a href="#cluster">Cluster</a></li>
							<ul>
								<li><a href="#installLib">Installation of libraries</a></li>
								<li><a href="#runG2SServer">Execute the G2S server</a></li>
								<li><a href="#efficentUse">How to efficiently use it</a></li>
							</ul>
						</ul>
					</aside>
				</div>
			</aside> -->
			<section id="main-content">

				
				<h1 id='briefOverview'>Brief overview</h1>
				<p>This page provides some extra information on how to do some common task. This page as some note to myself too &#128513;</p>

				<h1 id='multiplRealisation'>Multiple realization</h1>
				<p>A question that is frequently asked is how to do multiple realization </p>

				<h2>The lazy solution</h2>
				<p>The simplest solution is to do a for-loop over the realization. Each step requires to wait the load of the data, this creates an over head</p>
				<pre><code>
sims1=numpy.empty((250,250,numberOfSimulation));
for i in range(numberOfSimulation):
	sims1[:,:,i],_=g2s('-sa',computationServer,'-a','qs','-ti',ti,'-di',numpy.zeros((250,250))*numpy.nan,'-dt',numpy.ones((1,)),'-k',1.2,'-n',50,'-j',0.5,'-s',100+i);
				</code></pre>

				<h2>For-loop without overhead</h2>
				<p>By using the G2S submission queue, it's possible to remove major part of the over head.  This is the most versatile solution. This solution should be privileged over the lazy solution in case the computations are run on another machine. <br>Furthermore his solution as the advantage that the parameter can me change for each simulation.</p>
				<pre><code>
ids=numpy.empty((numberOfSimulation,), dtype='long');
for i in range(numberOfSimulation):
	ids[i]=g2s('-sa',computationServer,'-a','qs','-ti',ti,'-di',numpy.zeros((250,250))*numpy.nan,'-dt',numpy.ones((1,)),'-k',1.2,'-n',50,'-j',0.5,'-s',100+i,'-submitOnly');

sims2=numpy.empty((250,250,numberOfSimulation));
for i in range(numberOfSimulation):
	sims2[:,:,i],_=g2s('-sa',computationServer,'-waitAndDownload',ids[i]);
				</code></pre>

				<h2>Overdimensioning of the destination image</h2>
				<p>It another solution to get multiple simulations at once. This solution looks easier, but as much more limitation (same size, same parameters…), and therefore is ⚠️ <b>not guaranteed </b> to stay functional in the future. This last solution should only be considered in case of extremely parallelized simulation (number of threads >50) and/or extremely small simulations (less than 1e4 pixels pro-simulation)</p>
				<pre><code>
sims3,_=g2s('-sa',computationServer,'-a','qs','-ti',ti,'-di',numpy.zeros((numberOfSimulation,250,250))*numpy.nan,'-dt',numpy.ones((1,)),'-k',1.2,'-n',50,'-j',0.5);
				</code></pre>

				
				<h1 id='segmentSimulation'>How to do a simulation by segment</h1>
				<p>Here the challenge is to respect each zone in case high non-stationarity. QS tend to reduce issues related to non-stationarity. But do not remove them completely. Therefore here we assume that we have multiple training images, each respectively to another area.</p>

				<h2>Using a secondary variable</h2>
				<p>The first solution is to add a secondary variable with the information of non-stationarity. In this case the setting of the algorithm need to be identical between training images.</p>
				<pre><code>
ti1=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/bangladesh.tiff');
ti2=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/strebelle.tiff');

dt=[0];
N=300;

ti1_bis=cat(3,ti1,zeros(size(ti1)));
ti2_bis=cat(3,ti2,ones(size(ti2)));

localKernel=cat(3,kernel,padarray(15,25*[1,1]));
% localKernel=cat(3,kernel,kernel);

sim=g2s('-a','qs','-ti',ti1_bis,ti2_bis,'-di',cat(3,nan(size(tiSelection)),tiSelection),'-dt',[0,1],'-n',50,'-k',1.5,'-j',0.5,'-ki',localKernel);
imshow(medfilt2(sim(:,:,1)))
drawnow;
pause(5)

</code></pre>

<h2>Using training image indices</h2>
<p>The second solution is to use a training image index map, this requires that each training image represent a stationary subdomain. In this case the setting of the algorithm needs to be identical between training images too.</p>
<pre><code>
ti1=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/bangladesh.tiff');
ti2=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/strebelle.tiff');

dt=[0];
N=300;

sim=g2s('-a','qs','-ti',ti1,ti2,'-di',nan(size(tiSelection)),'-dt',dt,'-n',50,'-k',1.5,'-j',0.5,'-ki',kernel,'-ii',tiSelection);
imshow(medfilt2(sim))
pause(5)
</code></pre>

<h2>Simulating each subdomain sequentially</h2>
<p>The last solution is to do a simulation pro-domain, this allows changing the setting between each subdomain. However each subdomain is simulated sequential and therefore can be at the origin of some artifacts, regarding the order of simulations.</p>
<pre><code>
ti1=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/bangladesh.tiff');
ti2=imread('https://raw.githubusercontent.com/GAIA-UNIL/TrainingImagesTIFF/master/strebelle.tiff');

dt=[0];
N=300;

path=reshape(randperm(numel(tiSelection)),size(tiSelection));
p1=path;
p1(tiSelection==0)=-inf;
p2=path;
p2(tiSelection==1)=-inf;
sim=g2s('-a','qs','-ti',ti1,'-di',nan(size(tiSelection)),'-dt',dt,'-n',50,'-k',1.5,'-j',0.5,'-ki',kernel,'-sp',p1);
sim=g2s('-a','qs','-ti',ti2,'-di',sim,'-dt',dt,'-n',50,'-k',1.5,'-j',0.5,'-ki',kernel,'-sp',p2);
imshow(medfilt2(sim))
pause(5)
</code></pre>

				<!-- <h2 id='AspecRatio'>To compensate ratio aspect</h2>
				<p>Here the problem is to compensate ratio issue in case we use pixel that are not squared. Let me clairify directly this, there is no universal soolution to this problem ! &#128532; Here we will review many possible approch. </p>
 -->

				<h2 id='SuperResolution'>How to setup the algorithm to do superresolution ?</h2>
				<p>Here the challanges is to increase teh resolution using a HR-LR pair of training iamge and a low reoslution image as covariable to guide teh simulation</p>

<pre><code>
</code></pre>

<pre><code>
</code></pre>

<pre><code>
</code></pre>

<pre><code>
</code></pre>
				
				
 			</section>
			<aside id="sidebar">

				<!-- <a href="https://github.com/GAIA-UNIL/G2S/zipball/master" class="button">
					<small>Download</small>
					.zip file
				</a>
				<a href="https://github.com/GAIA-UNIL/G2S/tarball/master" class="button">
					<small>Download</small>
					.tar.gz file
				</a>



				<p class="repo-owner"><a href="https://github.com/GAIA-UNIL/G2S">G2S</a> is maintained by <a href="https://github.com/GAIA-UNIL/"> the GAIAlab from University of Lausanne</a>.</p>
 -->
			</aside>
		</div>
	</div>
	<footer>

	</footer>
</body>
</html>
